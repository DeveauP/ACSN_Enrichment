#!/usr/bin/env/R
####### ACSN enrichment analysis ####### 

#' @title Enrichment analysis function
#' @description Allows gene set enrichment analysis
#' @param Genes Character vector of genes that should be tested for enrichment
#' @param maps list of maps generated by format_from_gmt. Default: tests on all acsn maps
#' @param correction_multitest either FALSE, "bonferroni", "holm", "hochberg", "hommel", "BH", "fdr" (identical to BH), or "BY"
#' @param statistical test one of "fisher", "hypergeom"
#' @param min_module_size will remove from the analysis all modules which are (strictly) smaller than threshold
#' @param universe Universe on which the statistical analysis should be performed. Can be either "HUGO","ACSN", or a character vector of genes.
#' @param threshold : maximal p-value (corrected if correction is enabled) that will be displayed
enrichment<-function(Genes=NULL,
                    maps = list(ACSN_apop_formatted,
                                ACSN_cellcyc_formatted,
                                ACSN_dnarep_formatted,
                                ACSN_emtmotil_formatted,
                                ACSN_master_formatted,
                                ACSN_survival_formatted), 
                    correction_multitest = FALSE,
                    statistical_test = "fisher",
                    min_module_size = 5,
                    universe = "HUGO",
                    threshold = 1){
  
  ### Checking that gene list is unique
  Genes<-unique(Genes)
  Genes_size<-length(Genes)    
  
  ### Checking that parameters are correct
  if(sum(statistical_test %in% c("fisher", "hypergeom"))==0){
    stop("statistical_test should be one of 'fisher' or 'hypergeom'")
  }
  
  if(universe == "HUGO"){
    ###Total size of approved symbols, from http://www.genenames.org/cgi-bin/statistics, as of October 8th 2015
    size = 39480
  }
  
  else if(universe == "ACSN"){
    genesACSN<-character()
    iterator<-0
    for(lt in maps){
      iterator<-iterator+1
      ### extract modules of size >= module_size and get size of ACSN reduced by module size
      result<-data.frame()
      for(k in 1:dim(lt)[1]){
        spare_genes<-as.character(lt[k,-c(1,2)])
        S<-sum(spare_genes != "")
        if( S>= min_module_size){
          genesACSN<-unique(c(genesACSN,unique(spare_genes[spare_genes!=""])))
          result<-rbind(result,cbind(lt[k,1],S,t(spare_genes)))          
        }
      }
      size <- length(genesACSN)
      maps[[iterator]]<-result
    }
    is_in_ACSN<-Genes %in% genesACSN
    S<-sum(!is_in_ACSN)
    if(S > 0){ ### removing genes from list, that are not from ACSN
      warning(paste(S,"genes are not in ACSN modules and will be excluded from analysis"))
    }
    Genes<-Genes[is_in_ACSN]
    
  }
  else if(is.character(universe)){
    
    ### Change maps so that they only have gene names from universe and remove modules which are too small
    genesACSN<-character()
    i<-0
    genesACSN<-character()
    iterator<-0
    for(lt in maps){
      iterator<-iterator+1
      ### extract modules of size >= module_size and get size of ACSN reduced by universe and module size
      result<-data.frame()
      for(k in 1:dim(lt)[1]){
        spare_genes<-as.character(lt[k,-c(1,2)])
        spare_genes[!(spare_genes %in% universe)]<- ""
        test<-spare_genes != ""
        S<-sum(test)
        if( S>= min_module_size){
          genesACSN<-unique(c(genesACSN,unique(spare_genes[test])))
          result<-rbind(result,cbind(lt[k,1],S,t(spare_genes)))          
        }
      }
      size <- length(genesACSN)
      maps[[iterator]]<-result
    }
    is_in_ACSN<-Genes %in% genesACSN
    S<-sum(!is_in_ACSN)
    if(S > 0){ ### removing genes from list, that are not from ACSN
      warning(paste(S,"genes are not in maps modules and will be excluded from analysis"))
    }
    Genes<-Genes[is_in_ACSN]
    
  }
  else{
    stop("Invalid universe input: must be 'HUGO','ACSN', or a gene list")
  }

  ### get from list how many are in each sub-compartment
  result<-data.frame()
  ### what would be the expected?
  for(map in maps){
    modules<-map[,1:2]
    if(statistical_test == "fisher"){
       p.values<-apply(map,MARGIN = 1, FUN = function(z){
         short_z<-z[z!=""][-c(1,2)] ### remove empty slots, module name and length
         num<-as.numeric(as.character(z[2]))
         test<-Genes %in% short_z
         Gene_set<-paste(Genes[test],collapse = " ")
         Genes_in_module<-sum(test)
         return(c(Gene_set,fisher.test(x = matrix(c(Genes_in_module,
                                  num-Genes_in_module,
                                  Genes_size - Genes_in_module,
                                  size - num),
                                  nrow = 2))$p.value))
         
       })
    }else if(statistical_test == "hypergeom"){
      p.values<-apply(map,MARGIN = 1, FUN = function(z){
        short_z<-z[z!=""][-c(1,2)] ### remove empty slots, module name and length
        num<-as.numeric(as.character(z[2]))
        test<-Genes %in% short_z
        Genes_in_module<-sum(test)
        Gene_set<-paste(Genes[test],collapse = " ")
        if(Genes_in_module > 0){ ### Correction for depletion: phyper tests for P[X<=x]
          Genes_in_module<-Genes_in_module-1 
        }
        return(c(Gene_set,phyper(q = Genes_in_module,
               m = num,
               n = size - num,
               k = length(Genes),
               lower.tail = FALSE)))
        
      })
    }
    result<-rbind(result,cbind(modules,t(p.values)))
  }
  colnames(result)<-c("module","module_size","genes_in_module","p.value")
  if(is.logical(correction_multitest)){
    result<-result[as.numeric(as.character(result$p.value)) <= threshold,]
    if(!correction_multitest){
      return(result)
    }
    else{
      warning("If multiple correction is wanted, please use one of the listed parameters.")
      return(result)
    }
  }
  else{
    if(correction_multitest %in% c("bonferroni", "holm", "hochberg", "hommel", "BH", "fdr", "BY")){
      result$p.value.corrected<-p.adjust(as.numeric(as.character(result$p.value)),method = correction_multitest)
      result<-result[result$p.value.corrected <= threshold,]
      return(result)
    }
    else{
      result<-result[result$p.value <= threshold,]
      warning('correction multitest should be one of the following: "bonferroni", "holm", "hochberg", "hommel", "BH", "fdr", "BY"')
      return(result)
    }
  }
}

represent_enrichment<-function(enrichment){
  
  
  
}


format_from_gmt<-function(path = ""){
  max_length<-max(sapply(X=readLines(path),FUN = function(z){
    z2<-gsub("\t","",z)
    return(nchar(z)-nchar(z2))
  }))
  gmt<-read.csv(path,header = FALSE, 
                sep = "\t",fill = TRUE,
                col.names = sapply(X = 1:max_length,
                                   FUN = function(z){
                                     paste("V",z,sep="")
                                   }))
  
  result<-t(apply(gmt,1,FUN = function(z){
    pos<-grep(pattern = "\\*",x = z)
    res<-z
    res[pos]<-""
    return(res)
  }))
  result[,2]<-apply(result[,-(1:2)], 1, FUN = function(z) sum(z!=""))
  return(result)
}
