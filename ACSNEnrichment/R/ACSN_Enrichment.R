#!/usr/bin/env/R
####### ACSN enrichment analysis #######
####### Single sample analysis / single cohort analysis #######

#' @title Gene enrichment analysis from ACSN maps or gmt files
#' @description Compute and represent gene set enrichment from your data based on pre-saved maps from ACSN or user imported maps. The gene set enrichment can be run with hypergeometric test or Fisher exact test, 
#' and can use multiple corrections. Visualization of data can be done either by barplots or heatmaps.
#' @author Eric Bonnet <eric.bonnet at curie.fr>, Paul Deveau <paul.deveau at curie.fr>

#' Gene set enrichment analysis
#' @param Genes Character vector of genes that should be tested for enrichment
#' @param maps list of maps generated by format_from_gmt. Names of element of list will be used to track modules. Default: tests on all acsn maps.
#' @param correction_multitest either FALSE, "bonferroni", "holm", "hochberg", "hommel", "BH", "fdr" (identical to BH), or "BY"
#' @param statistical test one of "fisher", "hypergeom"
#' @param min_module_size will remove from the analysis all modules which are (strictly) smaller than threshold
#' @param universe Universe on which the statistical analysis should be performed. Can be either "HUGO","ACSN"( identical to "map_defined"), or a character vector of genes.
#' @param threshold : maximal p-value (corrected if correction is enabled) that will be displayed
#' @example enrichment(genes_test,min_module_size = 10, threshold = 0.05, maps = list(cellcycle = ACSN_cellcyc_formatted))
#' @export
enrichment<-function(Genes=NULL,
                     maps = ACSN_maps, 
                     correction_multitest = "BH",
                     statistical_test = "fisher",
                     min_module_size = 5,
                     universe = "map_defined",
                     threshold = 1){
  ### Checking maps
  if(is.data.frame(maps)){
    maps<-list(maps)
  }
  else if(!is.list(maps)){
    warning("maps should be a dataframe or a list of dataframes. Exiting")
    return(NA)
  }
  
  ### Checking that gene list is unique
  Genes<-unique(Genes)
  Genes_size<-length(Genes)    
  
  ### Checking that parameters are correct
  if(sum(statistical_test %in% c("fisher", "hypergeom"))==0){
    stop("statistical_test should be one of 'fisher' or 'hypergeom'")
  }
  
  if(universe == "HUGO"){
    ###Total size of approved symbols, from http://www.genenames.org/cgi-bin/statistics, as of October 8th 2015
    size = 39480
  }
  
  else if(universe == "ACSN" | universe == "map_defined"){
    genesACSN<-character()
    iterator<-0
    for(lt in maps){
      iterator<-iterator+1
      ### extract modules of size >= module_size and get size of ACSN reduced by module size
      result<-data.frame()
      for(k in 1:dim(lt)[1]){
        spare_genes<-as.character(lt[k,-c(1,2)])
        S<-sum(spare_genes != "")
        if( S>= min_module_size){
          genesACSN<-unique(c(genesACSN,unique(spare_genes[spare_genes!=""])))
          result<-rbind(result,cbind(lt[k,1],S,t(spare_genes)))          
        }
      }
      size <- length(genesACSN)
      maps[[iterator]]<-result
    }
    is_in_ACSN<-Genes %in% genesACSN
    S<-sum(!is_in_ACSN)
    if(S > 0){ ### removing genes from list, that are not from ACSN
      warning(paste(S,"genes are not in ACSN modules and will be excluded from analysis"))
    }
    Genes<-Genes[is_in_ACSN]
    
  }
  else if(is.character(universe)){
    
    ### Change maps so that they only have gene names from universe and remove modules which are too small
    genesACSN<-character()
    i<-0
    genesACSN<-character()
    iterator<-0
    for(lt in maps){
      iterator<-iterator+1
      ### extract modules of size >= module_size and get size of ACSN reduced by universe and module size
      result<-data.frame()
      for(k in 1:dim(lt)[1]){
        spare_genes<-as.character(lt[k,-c(1,2)])
        spare_genes[!(spare_genes %in% universe)]<- ""
        test<-spare_genes != ""
        S<-sum(test)
        if( S>= min_module_size){
          genesACSN<-unique(c(genesACSN,unique(spare_genes[test])))
          result<-rbind(result,cbind(lt[k,1],S,t(spare_genes)))          
        }
      }
      size <- length(genesACSN)
      maps[[iterator]]<-result
    }
    is_in_ACSN<-Genes %in% genesACSN
    S<-sum(!is_in_ACSN)
    if(S > 0){ ### removing genes from list, that are not from ACSN
      warning(paste(S,"genes are not in maps modules and will be excluded from analysis"))
    }
    Genes<-Genes[is_in_ACSN]
    
  }
  else{
    stop("Invalid universe input: must be 'HUGO','ACSN', or a gene list")
  }
  
  ### get from list how many are in each sub-compartment
  result<-data.frame()
  ### what would be the expected?
  tracker<-0
  map_names<-names(maps)
  if(is.null(map_names) & length(maps)>1){
    map_names<-paste("map",1:length(maps),sep = "_")
  }
  for(map in maps){
    tracker <- tracker + 1
    modules<-map[,1:2]
    if(length(maps)>1){
      modules[,1]<-paste(map_names[tracker],modules[,1],sep=":")
    }
    if(statistical_test == "fisher"){
      p.values<-apply(map,MARGIN = 1, FUN = function(z){
        short_z<-z[z!=""][-c(1,2)] ### remove empty slots, module name and length
        num<-cnum(z[2])
        test<-Genes %in% short_z
        Gene_set<-paste(Genes[test],collapse = " ")
        Genes_in_module<-sum(test)
        return(c(Gene_set,fisher.test(x = matrix(c(Genes_in_module,
                                                   num-Genes_in_module,
                                                   Genes_size - Genes_in_module,
                                                   size - num),
                                                 nrow = 2))$p.value))
        
      })
    }else if(statistical_test == "hypergeom"){
      p.values<-apply(map,MARGIN = 1, FUN = function(z){
        short_z<-z[z!=""][-c(1,2)] ### remove empty slots, module name and length
        num<-cnum(z[2])
        test<-Genes %in% short_z
        Genes_in_module<-sum(test)
        Gene_set<-paste(Genes[test],collapse = " ")
        if(Genes_in_module > 0){ ### Correction for depletion: phyper tests for P[X<=x]
          Genes_in_module<-Genes_in_module-1 
        }
        return(c(Gene_set,phyper(q = Genes_in_module,
                                 m = num,
                                 n = size - num,
                                 k = length(Genes),
                                 lower.tail = FALSE)))
        
      })
    }
    result<-rbind(result,cbind(modules,t(p.values)))
  }
  colnames(result)<-c("module","module_size","genes_in_module","p.value")
  result$p.value<-cnum(result$p.value)
  result$universe_size<-size
  result$genes_in_universe<-Genes_size
  if(is.logical(correction_multitest)){
    result<-result[cnum(result$p.value) <= threshold,]
    if(!correction_multitest){
      return(result)
    }
    else{
      warning("If multiple correction is wanted, please use one of the listed parameters.")
      return(result)
    }
  }
  else{
    if(correction_multitest %in% c("bonferroni", "holm", "hochberg", "hommel", "BH", "fdr", "BY")){
      result$p.value.corrected<-p.adjust(cnum(result$p.value),method = correction_multitest)
      result<-result[result$p.value.corrected <= threshold,]
      return(result)
    }
    else{
      result<-result[result$p.value <= threshold,]
      warning('correction multitest should be one of the following: "bonferroni", "holm", "hochberg", "hommel", "BH", "fdr", "BY"')
      return(result)
    }
  }
}

####### Multiplesample analysis / multiple cohorts analysis #######


#' @title Enrichment analysis function
#' @description Allows gene set enrichment analysis
#' @param Genes_by_sample List of character vectors. Each list element name should be a sample name, and each character vector the set of genes to test for the sample.
#' @param maps list of maps generated by format_from_gmt. Default: tests on all acsn maps
#' @param correction_multitest either FALSE, "bonferroni", "holm", "hochberg", "hommel", "BH", "fdr" (identical to BH), or "BY"
#' @param statistical test one of "fisher", "hypergeom"
#' @param min_module_size will remove from the analysis all modules which are (strictly) smaller than threshold
#' @param universe Universe on which the statistical analysis should be performed. Can be either "HUGO","ACSN" (identical to "map_defined"), or a character vector of genes.
#' @param threshold maximal p-value (corrected if correction is enabled) that will be displayed
#' @param cohort_threshold: if TRUE modules will be kept in all samples if at least one sample has p-value lower than threshold, otherwise the threshold is applied for each sample independently.
#' @export

multisample_enrichment<-function(Genes_by_sample=NULL,
                                 maps = ACSN_maps, 
                                 correction_multitest = "BH",
                                 statistical_test = "fisher",
                                 min_module_size = 5,
                                 universe = "map_defined",
                                 individual_threshold = 1,
                                 cohort_threshold = 1){
  
  if(cohort_threshold){
    result<-lapply(X = Genes_by_sample ,
                   FUN = function(z){
                     enrichment(Genes = z,
                                maps = maps,
                                correction_multitest = correction_multitest,
                                statistical_test = statistical_test,
                                min_module_size = min_module_size,
                                universe = universe,
                                threshold =  1)
                   })
    kept_genes<-character()
    for(sample in result){
      if(is.logical(correction_multitest)){
        kept_genes<-unique(c(kept_genes,sample[sample$p.value<=threshold,1]))
      }
      else{
        kept_genes<-unique(c(kept_genes,sample[sample$p.value.corrected<=threshold,1]))
      }
    }
    for(i in 1:length(result)){
      result[[i]]<-result[[i]][result[[i]][,1] %in% kept_genes,]
    }
  }
  else{
    result<-lapply(X = Genes_by_sample ,
                   FUN = function(z){
                     enrichment(Genes = z,
                                maps = maps,
                                correction_multitest = correction_multitest,
                                statistical_test = statistical_test,
                                min_module_size = min_module_size,
                                universe = universe,
                                threshold =  thresold)
                   })
    names(result)<-names(Genes_by_sample)
  }
  return(result)
  
}
#### Graphic representation of results ####
#'@title Graphic representation of enrichment
#'@param enrichment Data frame or list of dataframes with p-values or corrected p-values (whenever available) and module names for representation.
#'The name of the dataframe will be used as sample name.
#'@param plot Any of "heatmap" or "bar"
#'@param scale Any of "log" or "identity"
#'@param low Color to be used in heatmap mode corresponding to lowest value
#'@param high Color to be used in heatmap mode corresponding to highest value
#'@param nrow Number of rows of the grid for display in bar mode.
#'@param sample_name : used only is enrichment is a dataframe
#'@example represent_enrichment(enrichment = list(SampleA = enrichment_test[1:10,], SampleB = enrichment_test[3:10,]), plot = "heatmap", scale = "log")
#'@import ggplot2 gridExtra
#'
represent_enrichment<-function(enrichment, plot = "heatmap" , scale = "log", 
                               low = "steelblue" , high ="white",
                               nrow = 1,sample_name = "Sample",
                               na.value = "grey"){
  
  
  if(is.data.frame(enrichment)){
    if("p.value.corrected" %in% colnames(enrichment)){
      enrichment$p.values<-enrichment$p.value.corrected
    }
    else if("p.value" %in% colnames(enrichment)){
      enrichment$p.values<-enrichment$p.value
    }
    else{
      warning("dataframe has no column 'p.value' or 'p.value.corrected'. Exiting!")
      return(NA)
    }
    enrichment$sample_name<-sample_name 
    enrichment$p.values<-cnum(enrichment$p.values)
    if(plot == "heatmap"){
      
      q<-ggplot2::ggplot(enrichment,
                         aes_string(x= "sample_name",
                                    y = "module", 
                                    fill = "p.values"))+ggplot2::xlab("")+ ggplot2::ylab("Modules") + ggplot2::geom_tile()
      if(scale == "log"){
        q<- q + ggplot2::scale_fill_gradient("p-values",low = low , high = high, na.value = na.value, trans = "log")
      }
      else{
        q<-q+ ggplot2::scale_fill_gradient("p-values",low = low , high = high, na.value = na.value)
      }
      
    }
    else{
      q<-ggplot2::qplot(x = enrichment$module, y = enrichment$p.values,
                        xlab = "Modules", ylab = "p-values")
      if(scale == "log"){
        q<- q + ggplot2::scale_y_continuous(trans = "log")
      }
    }    
    q<-q+ggplot2::theme_minimal()+ggplot2::theme(axis.text.x = element_text(angle = 90, hjust = 0), axis.ticks = ggplot2::element_blank())
    q<-q+ggplot2::geom_bar(stat = "identity")
  }
  else if(is.list(enrichment)){
    sample_names<-names(enrichment)
    if(is.null(sample_names)){
      warning("Your list has no names... Will use numbers instead")
      sample_names<-1:length(enrichment)
    }
    if(plot == "heatmap"){
      dataset<-data.frame()
      
      ### check if there is a need to add NAs for modules which are not present in all datasets
      all_equal<-TRUE
      modules<-as.character(enrichment[[1]]$module)
      for(sample in enrichment){
        if(!setequal(modules,as.character(sample$module))){
          all_equal<-FALSE
          modules<-unique(c(modules,as.character(sample$module)))
        }
      }
      tracker<-0
      if(all_equal){
        
        for(sample in enrichment){ ### Modules are present in all samples
          tracker<-tracker+1
          if("p.value.corrected" %in% colnames(sample)){
            dataset<-rbind(dataset, cbind(modules,sample_names[tracker],cnum(sample$p.value.corrected)))
          }
          else if("p.value" %in% colnames(sample)){
            dataset<-rbind(dataset, cbind(modules,sample_names[tracker],cnum(sample$p.value)))
          }
          else{
            warning(paste("Element", sample_names[tracker],"has no p.value column"))
            return(NA)
          }
        }
        colnames(dataset)<-c("module","sample_name","p.values")
      }
      else{ ###need to fill with NAs
        ### Not functional yet
        
        for(sample in enrichment){
          tracker<-tracker + 1

          test<-modules %in% as.character(sample$module)
          restricted_modules<-as.character(modules[test])
          position_modules<-as.numeric(sapply(X = restricted_modules,FUN = function(z){
            which(sample$module ==z)
          }))
          
          if(sum(!test)>0){ ### complement only when necessary
            complement<-as.character(modules[!test])
            if("p.value.corrected" %in% colnames(sample)){ ### 
             
              spare_dataset<-rbind(cbind(module = restricted_modules, sample_name = sample_names[tracker], 
                                         p.values = cnum(sample$p.value.corrected[position_modules])),
                                   cbind(module = complement, 
                                         sample_name = sample_names[tracker],
                                         p.values = NA))

            }
            else if("p.value" %in% colnames(sample)){ ### 
              spare_dataset<-rbind(cbind(restricted_modules, sample_names[tracker], cnum(sample$p.value[position_modules])),
                                   cbind(complement_modules, sample_names[tracker],NA))

            } else{
              warning(paste("Element", sample_names[tracker],"has no p.value column"))
              return(NA)
            }
            colnames(spare_dataset)<-c("module","sample_name","p.values")
            dataset<-rbind(dataset, spare_dataset)
          }
          else{ ### rbind dataframe with values
            if("p.value.corrected" %in% colnames(sample)){ ### 
             
              spare_dataset<-cbind(module = restricted_modules, sample_name = sample_names[tracker], 
                                         p.values = cnum(sample$p.value.corrected[position_modules]))
                                
            }
            else if("p.value" %in% colnames(sample)){ ### 
              spare_dataset<-cbind(restricted_modules, sample_names[tracker], cnum(sample$p.value[position_modules]))
            } else{
              warning(paste("Element", sample_names[tracker],"has no p.value column"))
              return(NA)
            }
            colnames(spare_dataset)<-c("module","sample_name","p.values")
            dataset<-rbind(dataset, spare_dataset)
            
          }
        }
      }
      dataset$p.values<-cnum(dataset$p.values)
      ### Plot heatmap
      q<-ggplot2::ggplot(dataset,
                         aes_string(x= "sample_name",
                                    y = "module", 
                                    fill = "p.values"))+ggplot2::xlab("")+ ggplot2::ylab("Modules") + ggplot2::geom_tile()
      if(scale == "log"){
        q<- q + ggplot2::scale_fill_gradient("p-values",low = low , high = high, na.value = na.value, trans = "log")
      }
      else{
        q<-q+ ggplot2::scale_fill_gradient("p-values",low = low , high = high, na.value = na.value)
      }
      q<-q+ggplot2::theme_minimal()+ggplot2::theme(axis.text.x = element_text(angle = 90, hjust = 0), axis.ticks = ggplot2::element_blank())
    }
    else{ ### barplot with grid
      names_sample<-names(enrichment)
      for(s in 1:length(enrichment)){
        if(s==1){
          plot<-represent_enrichment(enrichment[[s]], plot = "bar" , 
                                     scale = scale, 
                                     sample_name = names_sample[s])
        }
        else{
          plot<-c(plot,represent_enrichment(enrichment[[s]], plot = "bar" , 
                                            scale = scale, 
                                            sample_name = names_sample[s]))
        }
        
        print(plot[[s]])
      }
      if(length(enrichment)%%nrow ==0){
        ncol <- length(enrichment)/nrow
      }
      else{
        ncol <- floor(length(enrichment)/nrow)+1
      }
      return(plot)
      plots<-gridExtra::arrangeGrob(grobs = plot,nrow =  nrow)
      
    }
    
  }
  else{
    warning("Wrong input format for enrichment!")
    return(NA)
    
  }
  return(q)
  
}

#' Convert to numeric
cnum<-function(x){
  return(as.numeric(as.character(x)))
}


#' Import data from gmt files
#' Convert gmt file to dataframe that can be used for anaysis
#'@param path Path to the gmt file to be imported
#'@export

format_from_gmt<-function(path = ""){
  
  max_length<-max(sapply(X=readLines(path),FUN = function(z){
    z2<-gsub("\t","",z)
    return(nchar(z)-nchar(z2))
  }))
  
  
  gmt<-read.csv(path,header = FALSE, 
                sep = "\t",fill = TRUE,
                col.names = sapply(X = 1:max_length,
                                   FUN = function(z){
                                     paste("V",z,sep="")
                                   }))
  
  result<-t(apply(gmt,1,FUN = function(z){
    pos<-grep(pattern = "\\*",x = z)
    res<-z
    res[pos]<-""
    return(res)
  }))
  
  
  result[,2]<-apply(result[,-(1:2)], 1, FUN = function(z) sum(z!=""))
  
  return(result)
}
